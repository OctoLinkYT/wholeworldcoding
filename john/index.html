<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>John Learns Things</title>
  <style>
    body {
      background: #0d0d0d;
      color: #f0f0f0;
      font-family: 'Courier New', monospace;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    canvas {
      background: #1a1a1a;
      display: block;
      margin: 20px auto;
      border: 2px solid #333;
      box-shadow: 0 0 20px #0ff;
    }
    h1 {
      color: #4af;
    }
    #goals {
      max-width: 600px;
      margin: 0 auto 1em;
      background: #111;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 8px;
    }
    #goals ul {
      list-style: none;
      padding: 0;
      margin: 0;
      text-align: left;
    }
    #goals li::before {
      content: "üß† ";
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1>ü§ñ Meet John, the Learning Cube</h1>
  <p>He learns to move, jump, collect food, and fight!</p>
  <canvas id="game" width="600" height="300"></canvas>

  <div id="goals">
    <h3>üéØ Goal Timeline</h3>
    <ul id="goalList">
      <li>üçñ Find the food on the platform</li>
    </ul>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const floor = 300;
    const gravity = 0.5;

    const goalList = document.getElementById("goalList");
    function addGoal(goal) {
      const li = document.createElement("li");
      li.textContent = goal;
      goalList.appendChild(li);
    }

    class Env {
      constructor() {
        this.platforms = [];
        this.reset();
      }

      reset() {
        this.x = 50;
        this.vx = 0;
        this.vy = 0;
        this.width = 30;
        this.height = 30;
        this.health = 100;
        this.maxHealth = 100;
        this.thought = "";
        this.done = false;
        this.steps = 0;
        this.foodCollected = 0;
        this.projectiles = [];
        this.enemies = [];

        this.generatePlatforms();
        this.setStartOnPlatform();

        this.food = this.spawnFood();

        return this.getState();
      }

      setStartOnPlatform() {
        const startPlat = this.platforms[Math.floor(Math.random() * this.platforms.length)];
        this.x = startPlat.x + 10;
        this.y = startPlat.y - this.height;
      }

      generatePlatforms() {
        this.platforms = [];
        for (let i = 0; i < 5; i++) {
          let x = Math.random() * (canvas.width - 100);
          let y = 100 + Math.random() * 150;
          this.platforms.push({ x, y, w: 100, h: 10 });
        }
      }

      spawnFood() {
        const plat = this.platforms[Math.floor(Math.random() * this.platforms.length)];
        return {
          x: plat.x + 40,
          y: plat.y - 15,
          w: 15,
          h: 15,
          collected: false
        };
      }

      setThought(text) {
        this.thought = text;
      }

      getState() {
        return tf.tensor2d([[this.x / 600, this.y / 300, this.vx / 10, this.vy / 10, this.onPlatform() ? 1 : 0]]);
      }

      onPlatform() {
        for (let plat of this.platforms) {
          if (
            this.y + this.height >= plat.y &&
            this.y + this.height <= plat.y + 10 &&
            this.x + this.width > plat.x &&
            this.x < plat.x + plat.w
          ) {
            return true;
          }
        }
        return false;
      }

      step(action) {
        if (action === 0) this.vx = -2.5;
        if (action === 1) this.vx = 2.5;
        if (action === 2 && this.onPlatform()) {
          this.vy = -10;
        }

        this.x += this.vx;
        this.y += this.vy;
        this.vy += gravity;
        this.vx *= 0.9;

        // Boundaries & punishment
        if (this.x < 0 || this.x + this.width > canvas.width) {
          this.health -= 10;
          this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
        }

        // Platform collision
        if (!this.onPlatform()) {
          // Fall off screen = death
          if (this.y > canvas.height) {
            this.health = 0;
          }
        } else {
          this.vy = 0;
          this.y = this.platforms.find(p => this.y + this.height >= p.y && this.x + this.width > p.x && this.x < p.x + p.w).y - this.height;
        }

        // Collect food
        let reward = 0.01;
        if (
          !this.food.collected &&
          this.x + this.width > this.food.x &&
          this.x < this.food.x + this.food.w &&
          this.y + this.height > this.food.y
        ) {
          this.food.collected = true;
          this.foodCollected++;
          addGoal("‚öîÔ∏è Shoot enemies!");
          reward += 1.0;

          // Spawn an enemy
          const ex = Math.random() < 0.5 ? 0 : canvas.width - 20;
          this.enemies.push({ x: ex, y: 250, w: 20, h: 20, vx: ex === 0 ? 1 : -1 });
        }

        // Projectiles
        if (this.foodCollected > 0 && this.steps % 60 === 0) {
          this.projectiles.push({ x: this.x + this.width / 2, y: this.y + 10, vx: 4, w: 5, h: 5 });
          this.foodCollected--;
        }

        for (let p of this.projectiles) p.x += p.vx;
        this.projectiles = this.projectiles.filter(p => p.x < canvas.width);

        // Enemies move and check for collision
        for (let enemy of this.enemies) {
          enemy.x += enemy.vx;

          for (let p of this.projectiles) {
            if (
              p.x < enemy.x + enemy.w &&
              p.x + p.w > enemy.x &&
              p.y < enemy.y + enemy.h &&
              p.y + p.h > enemy.y
            ) {
              enemy.hit = true;
            }
          }

          if (
            this.x < enemy.x + enemy.w &&
            this.x + this.width > enemy.x &&
            this.y < enemy.y + enemy.h &&
            this.y + this.height > enemy.y
          ) {
            this.health -= 20;
            enemy.hit = true;
          }
        }

        this.enemies = this.enemies.filter(e => !e.hit);

        this.steps++;
        if (this.health <= 0) {
          this.explode();
          return { state: this.reset(), reward: -1, done: false };
        }

        if (this.steps > 1500) {
          this.done = true;
        }

        return { state: this.getState(), reward, done: this.done };
      }

      explode() {
        for (let i = 0; i < 10; i++) {
          ctx.fillStyle = "red";
          ctx.fillRect(this.x + Math.random() * 20 - 10, this.y + Math.random() * 20 - 10, 4, 4);
        }
      }

      render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Platforms
        for (let plat of this.platforms) {
          ctx.fillStyle = "#444";
          ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
        }

        // Food
        if (!this.food.collected) {
          ctx.fillStyle = "gold";
          ctx.fillRect(this.food.x, this.food.y, this.food.w, this.food.h);
        }

        // Enemies
        for (let e of this.enemies) {
          ctx.fillStyle = "red";
          ctx.fillRect(e.x, e.y, e.w, e.h);
        }

        // Projectiles
        for (let p of this.projectiles) {
          ctx.fillStyle = "#0ff";
          ctx.fillRect(p.x, p.y, p.w, p.h);
        }

        // John
        ctx.fillStyle = "#4af";
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x + 5, this.y + 8, 5, 5);
        ctx.fillRect(this.x + 20, this.y + 8, 5, 5);
        ctx.fillText("John", this.x + 5, this.y - 5);

        // Thought bubble
        if (this.thought) {
          ctx.fillStyle = "#fff";
          ctx.font = "10px monospace";
          ctx.fillText(`Thinking: ${this.thought}`, this.x - 10, this.y - 20);
        }

        // Health bar
        ctx.fillStyle = "#fff";
        ctx.fillText("Health", 10, 10);
        ctx.fillStyle = "green";
        ctx.fillRect(60, 2, (this.health / this.maxHealth) * 100, 8);
        ctx.strokeStyle = "#fff";
        ctx.strokeRect(60, 2, 100, 8);
      }
    }

    class Agent {
      constructor() {
        this.model = this.createModel();
        this.optimizer = tf.train.adam(0.01);
      }

      createModel() {
        const model = tf.sequential();
        model.add(tf.layers.dense({ units: 24, inputShape: [5], activation: 'relu' }));
        model.add(tf.layers.dense({ units: 3, activation: 'softmax' }));
        return model;
      }

      async train(episodes = 100) {
        for (let e = 0; e < episodes; e++) {
          const env = new Env();
          let rewards = [], actions = [], states = [];
          let state = env.reset();

          while (!env.done) {
            env.render();
            const actionProbs = this.model.predict(state);
            const probs = actionProbs.dataSync();
            const action = tf.multinomial(actionProbs, 1).dataSync()[0];

            const emoji = probs[action] > 0.9 ? "ü§©" : probs[action] > 0.66 ? "üòÅ" : probs[action] > 0.33 ? "üòê" : "üòï";
            env.setThought(`${emoji} ${["‚Üê", "‚Üí", "‚Üë"][action]} (${probs[action].toFixed(2)})`);

            const { state: nextState, reward, done } = env.step(action);

            states.push(state); actions.push(action); rewards.push(reward);
            state = nextState;

            await tf.nextFrame();
          }

          const discounted = this.discountRewards(rewards);
          const inputs = tf.concat(states);
          const labels = tf.tensor1d(actions, 'int32');
          const advantages = tf.tensor1d(discounted);

          await this.optimizer.minimize(() => {
            const logits = this.model.apply(inputs);
            const labelsOneHot = tf.oneHot(labels, 3);
            const logProbs = tf.log(tf.sum(tf.mul(logits, labelsOneHot), 1));
            return tf.neg(tf.mean(tf.mul(logProbs, advantages)));
          });

          console.log(`Episode ${e + 1} complete. Total reward: ${rewards.reduce((a, b) => a + b, 0).toFixed(2)}`);
        }

        alert("üéâ John got tougher and smarter!");
      }

      discountRewards(rewards, gamma = 0.95) {
        let discounted = [], r = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
          r = rewards[t] + gamma * r;
          discounted[t] = r;
        }
        return discounted;
      }
    }

    const agent = new Agent();
    agent.train(100);
  </script>
</body>
</html>