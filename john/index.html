<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>John Learns Things</title>
  <style>
    body {
      background: #0d0d0d;
      color: #f0f0f0;
      font-family: 'Courier New', monospace;
      text-align: center;
      margin: 0;
      padding: 0;
    }
    canvas {
      background: #1a1a1a;
      display: block;
      margin: 20px auto;
      border: 2px solid #333;
      box-shadow: 0 0 20px #0ff;
    }
    h1 {
      color: #4af;
    }
    #goals {
      max-width: 600px;
      margin: 0 auto 1em;
      background: #111;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 8px;
    }
    #goals ul {
      list-style: none;
      padding: 0;
      margin: 0;
      text-align: left;
    }
    #goals li::before {
      content: "üß† ";
      margin-right: 5px;
    }
  </style>
</head>
<body>
  <h1>ü§ñ Meet John, the Learning Cube</h1>
  <p>He learns to move, jump, collect food, and fight enemies!</p>

  <canvas id="game" width="600" height="300"></canvas>

  <div id="goals">
    <h3>üéØ Goal Timeline</h3>
    <ul id="goalList">
      <li>üçñ Find the food</li>
    </ul>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.10.0/dist/tf.min.js"></script>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const floor = 280;
    const gravity = 0.5;

    const goalList = document.getElementById("goalList");
    function addGoal(goal) {
      const li = document.createElement("li");
      li.textContent = goal;
      goalList.appendChild(li);
    }

    function randomX() {
      return 100 + Math.random() * 400;
    }

    class Env {
      constructor() {
        this.reset();
      }

      reset() {
        this.x = 50; this.y = 250;
        this.vx = 0; this.vy = 0;
        this.ax = 0;
        this.ammo = 0;
        this.projectiles = [];
        this.enemies = [];
        this.done = false; this.onGround = true;
        this.steps = 0;
        this.thought = "";
        this.food = this.spawnFood();
        return this.getState();
      }

      spawnFood() {
        return { x: randomX(), y: 250, w: 15, h: 15, collected: false };
      }

      spawnEnemy() {
        const ex = Math.random() < 0.5 ? 550 : 100;
        this.enemies.push({ x: ex, y: 250, w: 30, h: 30 });
      }

      setThought(text) {
        this.thought = text;
      }

      getState() {
        return tf.tensor2d([[this.x / 600, this.y / 300, this.vx / 10, this.vy / 10, this.onGround ? 1 : 0]]);
      }

      fireProjectile() {
        if (this.ammo > 0) {
          this.projectiles.push({ x: this.x + 15, y: this.y + 15, vx: 4 });
          this.ammo--;
        }
      }

      step(action) {
        this.ax = 0;
        if (action === 0) this.ax = -0.4;
        if (action === 1) this.ax = 0.4;
        if (action === 2 && this.onGround) {
          this.vy = -10;
          this.onGround = false;
        }
        if (action === 3) this.fireProjectile();

        this.vx += this.ax;
        this.vx *= 0.9;
        this.x += this.vx;
        this.y += this.vy;
        this.vy += gravity;

        if (this.y + 30 >= floor) {
          this.y = floor - 30;
          this.vy = 0;
          this.onGround = true;
        }

        if (this.x < 0 || this.x + 30 > canvas.width) {
          this.x = Math.max(0, Math.min(canvas.width - 30, this.x));
          this.vx = 0;
        }

        let reward = 0.01;

        if (!this.food.collected &&
            this.x + 30 > this.food.x &&
            this.x < this.food.x + this.food.w &&
            this.y + 30 > this.food.y) {
          this.food.collected = true;
          this.ammo = 3;
          reward += 1.0;
          addGoal("‚öîÔ∏è Use ammo to defeat the enemy!");
          this.spawnEnemy();
          this.food = this.spawnFood();
        }

        this.projectiles.forEach(p => p.x += p.vx);
        this.projectiles = this.projectiles.filter(p => p.x < canvas.width);

        this.enemies.forEach(e => {
          for (let p of this.projectiles) {
            if (p.x > e.x && p.x < e.x + e.w && p.y > e.y && p.y < e.y + e.h) {
              e.dead = true;
              reward += 0.5;
            }
          }
        });
        this.enemies = this.enemies.filter(e => !e.dead);

        this.steps++;
        if (this.steps > 1500) this.done = true;

        return { state: this.getState(), reward, done: this.done };
      }

      render() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#333";
        ctx.fillRect(0, floor, canvas.width, 20);

        // Food
        if (!this.food.collected) {
          ctx.fillStyle = "gold";
          ctx.fillRect(this.food.x, this.food.y, this.food.w, this.food.h);
        }

        // Projectiles
        ctx.fillStyle = "#0ff";
        this.projectiles.forEach(p => {
          ctx.fillRect(p.x, p.y, 5, 5);
        });

        // Enemies
        ctx.fillStyle = "#f44";
        this.enemies.forEach(e => {
          ctx.fillRect(e.x, e.y, e.w, e.h);
        });

        // John
        ctx.fillStyle = "#4af";
        ctx.fillRect(this.x, this.y, 30, 30);
        ctx.fillStyle = "#fff";
        ctx.fillRect(this.x + 5, this.y + 8, 5, 5);
        ctx.fillRect(this.x + 20, this.y + 8, 5, 5);
        ctx.font = "10px monospace";
        ctx.fillText("John", this.x + 5, this.y - 5);

        if (this.thought) {
          ctx.fillStyle = "#fff";
          ctx.font = "10px monospace";
          ctx.fillText(`Thinking: ${this.thought}`, this.x - 10, this.y - 20);
        }

        if (this.food.collected && this.steps < 30) {
          ctx.fillStyle = "gold";
          ctx.font = "12px monospace";
          ctx.fillText("Yum! üòã", this.x + 5, this.y - 35);
        }
      }
    }

    class Agent {
      constructor() {
        this.model = this.createModel();
        this.optimizer = tf.train.adam(0.01);
      }

      createModel() {
        const model = tf.sequential();
        model.add(tf.layers.dense({ units: 24, inputShape: [5], activation: 'relu' }));
        model.add(tf.layers.dense({ units: 4, activation: 'softmax' })); // 4 actions now
        return model;
      }

      async train(episodes = 200) {
        for (let e = 0; e < episodes; e++) {
          const env = new Env();
          let rewards = [], actions = [], states = [];
          let state = env.reset();

          while (!env.done) {
            env.render();
            const actionProbs = this.model.predict(state);
            const probs = actionProbs.dataSync();
            const action = tf.multinomial(actionProbs, 1).dataSync()[0];

            const symbols = ["‚Üê", "‚Üí", "‚Üë", "üî´"];
            let confidence = probs[action];
            let emoji = "üòï";
            if (confidence > 0.33) emoji = "üòê";
            if (confidence > 0.66) emoji = "üòÅ";
            if (confidence > 0.9) emoji = "ü§©";
            env.setThought(`${emoji} ${symbols[action]} (${confidence.toFixed(2)})`);

            const { state: nextState, reward, done } = env.step(action);

            states.push(state); actions.push(action); rewards.push(reward);
            state = nextState;

            await tf.nextFrame();
          }

          const discounted = this.discountRewards(rewards);
          const inputs = tf.concat(states);
          const labels = tf.tensor1d(actions, 'int32');
          const advantages = tf.tensor1d(discounted);

          await this.optimizer.minimize(() => {
            const logits = this.model.apply(inputs);
            const labelsOneHot = tf.oneHot(labels, 4);
            const logProbs = tf.log(tf.sum(tf.mul(logits, labelsOneHot), 1));
            return tf.neg(tf.mean(tf.mul(logProbs, advantages)));
          });

          console.log(`Episode ${e + 1} complete. Total reward: ${rewards.reduce((a, b) => a + b, 0).toFixed(2)}`);
        }

        alert("üéâ John has evolved!");
      }

      discountRewards(rewards, gamma = 0.95) {
        let discounted = [], r = 0;
        for (let t = rewards.length - 1; t >= 0; t--) {
          r = rewards[t] + gamma * r;
          discounted[t] = r;
        }
        return discounted;
      }
    }

    const agent = new Agent();
    agent.train(150);
  </script>
</body>
</html>